#!/usr/bin/env bash
# sat - Satellite installer (router)

source "$HOME/.config/bash/modules/universal/paths.sh"
source "$BASHRC/bin/lib/sat/common.sh"

case "$1" in
    install|i)
        [[ -z "$2" ]] && { echo "Usage: sat install <program> [--rust|--python|--node|--go|--system]"; exit 1; }
        shift
        source "$BASHRC/bin/lib/sat/install.sh"
        sat_install "$@"
        ;;

    search)
        [[ -z "$2" ]] && { echo "Usage: sat search <program> [--wrap]"; exit 1; }
        shift
        source "$BASHRC/bin/lib/sat/search.sh"
        sat_search "$@"
        ;;

    uninstall|remove|rm)
        [[ -z "$2" ]] && { echo "Usage: sat uninstall <program> [program2] ..."; exit 1; }
        shift
        for PROGRAM in "$@"; do
            SOURCE=$(manifest_get "$PROGRAM")
            TRACKED=true
            # If not tracked, try to detect source
            if [[ -z "$SOURCE" ]]; then
                if ! command -v "$PROGRAM" &>/dev/null; then
                    status "$PROGRAM not found"
                    continue
                fi
                SOURCE=$(detect_source "$PROGRAM")
                if [[ -z "$SOURCE" || "$SOURCE" == "unknown" ]]; then
                    status "$PROGRAM source unknown, can't remove"
                    continue
                fi
                TRACKED=false
            fi
            printf "Removing %s\n" "$PROGRAM"
            if pkg_remove "$PROGRAM" "$SOURCE"; then
                [[ "$TRACKED" == true ]] && manifest_remove "$PROGRAM"
                status_ok "$PROGRAM removed" "$SOURCE"
            else
                status_fail "$PROGRAM removal failed"
            fi
        done
        # Clear stale hash entries
        hash -r
        ;;

    shell)
        shift
        source "$BASHRC/bin/lib/sat/shell.sh"
        sat_shell "$@"
        ;;

    list|ls)
        # Check for session manifest (sat shell)
        session_manifest=""
        [[ -n "$SAT_SESSION" ]] && session_manifest="/tmp/sat-shell/$SAT_SESSION/manifest"

        has_content=false

        # Show session tools first (if in sat shell)
        if [[ -n "$session_manifest" && -f "$session_manifest" ]]; then
            echo "Session tools (temporary):"
            while IFS='=' read -r key value; do
                [[ "$key" != "TOOL" ]] && continue
                src=$(grep "^SOURCE_$value=" "$session_manifest" | cut -d= -f2)
                display=$(source_display "$src")
                color=$(source_color "$display")
                printf "  ${C_DIM}%-20s${C_RESET} [${color}%s${C_RESET}]\n" "$value" "$display"
            done < "$session_manifest"
            echo ""
            has_content=true
        fi

        # Show tracked packages
        if [[ -s "$SAT_MANIFEST" ]]; then
            echo "Tracked by sat:"
            stale=()
            while IFS='=' read -r prog source; do
                [[ -z "$prog" ]] && continue
                display=$(source_display "$source")
                color=$(source_color "$display")
                light=$(source_light "$source")
                if command -v "$prog" &>/dev/null; then
                    printf "  ${light}%-20s${C_RESET} [${color}%s${C_RESET}]\n" "$prog" "$display"
                else
                    printf "  ${C_DIM}%-20s [%s] (not found)${C_RESET}\n" "$prog" "$display"
                    stale+=("$prog")
                fi
            done < "$SAT_MANIFEST"
            if [[ ${#stale[@]} -gt 0 ]]; then
                echo ""
                echo "Cleaning ${#stale[@]} stale entries..."
                for prog in "${stale[@]}"; do
                    manifest_remove "$prog"
                done
            fi
            has_content=true
        fi

        [[ "$has_content" == false ]] && echo "No packages tracked by sat"
        ;;

    track)
        [[ -z "$2" ]] && { echo "Usage: sat track <program> [program2] ..."; exit 1; }
        shift
        for prog in "$@"; do
            if [[ -n "$(manifest_get "$prog")" ]]; then
                echo "$prog: already tracked"
                continue
            fi
            bin=$(command -v "$prog" 2>/dev/null)
            if [[ -z "$bin" ]]; then
                echo "$prog: not found"
                continue
            fi
            src=$(detect_source "$prog")
            [[ -z "$src" || "$src" == "unknown" ]] && { echo "$prog: unknown source, skipping"; continue; }
            manifest_add "$prog" "$src"
            display=$(source_display "$src")
            color=$(source_color "$display")
            printf "%-20s [${color}%s${C_RESET}] tracked\n" "$prog" "$display"
        done
        ;;

    scan)
        echo "Scanning ecosystem directories..."
        # Session manifest (if inside sat shell)
        session_manifest=""
        [[ -n "$SAT_SESSION" ]] && session_manifest="/tmp/sat-shell/$SAT_SESSION/manifest"

        declare -A scan_dirs=(
            ["cargo"]="$HOME/.cargo/bin $HOME/.config/bash/dev-tools/cargo/bin"
            ["npm"]="$HOME/.config/bash/dev-tools/npm/bin $HOME/.npm-global/bin"
            ["uv"]="$HOME/.local/share/uv/tools"
            ["go"]="$HOME/go/bin $HOME/.config/bash/dev-tools/go/bin"
            ["brew"]="/home/linuxbrew/.linuxbrew/bin"
            ["nix"]="$HOME/.nix-profile/bin"
        )
        # Check if binary is from a git repo
        is_from_repo() {
            local bin="$1"
            local real=$(readlink -f "$bin" 2>/dev/null || echo "$bin")
            local dir=$(dirname "$real")
            while [[ "$dir" != "/" && "$dir" != "$HOME" ]]; do
                [[ -d "$dir/.git" ]] && return 0
                dir=$(dirname "$dir")
            done
            return 1
        }
        # Check if tool is in session manifest (temp sat shell install)
        in_session() {
            [[ -z "$session_manifest" || ! -f "$session_manifest" ]] && return 1
            grep -q "^TOOL=$1\$" "$session_manifest" 2>/dev/null
        }
        # Skip sub-commands, dev tools, internal binaries
        is_excluded() {
            local p="$1"
            case "$p" in
                git-*|scalar)                return 0 ;;  # git subcommands
                cargo-*|clippy-driver)       return 0 ;;  # cargo subcommands
                rust[!u]*|rls)               return 0 ;;  # rust toolchain (keep rustup)
                trash-*)                     return 0 ;;  # trash-cli subcommands
                *-config|*-settings)         return 0 ;;  # library dev tools
                .*|_*)                       return 0 ;;  # hidden/internal
            esac
            return 1
        }
        # First pass: prune excluded entries from manifest
        pruned=0
        while IFS='=' read -r prog source; do
            [[ -z "$prog" ]] && continue
            if is_excluded "$prog"; then
                manifest_remove "$prog"
                printf "  ${C_DIM}- %-20s (excluded)${C_RESET}\n" "$prog"
                ((pruned++))
            fi
        done < "$SAT_MANIFEST"

        # Second pass: add new packages from ecosystem dirs
        added=0
        for src in "${!scan_dirs[@]}"; do
            for dir in ${scan_dirs[$src]}; do
                [[ ! -d "$dir" ]] && continue
                for bin in "$dir"/*; do
                    [[ ! -x "$bin" ]] && continue
                    prog=$(basename "$bin")
                    is_excluded "$prog" && continue
                    [[ -n "$(manifest_get "$prog")" ]] && continue
                    in_session "$prog" && continue
                    manifest_add "$prog" "$src"
                    display=$(source_display "$src")
                    color=$(source_color "$display")
                    printf "  ${color}+${C_RESET} %-20s [${color}%s${C_RESET}]\n" "$prog" "$display"
                    ((added++))
                done
            done
        done

        # Third pass: scan ~/.local/bin for repo-installed tools
        if [[ -d "$HOME/.local/bin" ]]; then
            for bin in "$HOME/.local/bin"/*; do
                [[ ! -x "$bin" ]] && continue
                prog=$(basename "$bin")
                is_excluded "$prog" && continue
                [[ -n "$(manifest_get "$prog")" ]] && continue
                in_session "$prog" && continue
                if is_from_repo "$bin"; then
                    manifest_add "$prog" "repo"
                    printf "  ${C_REPO}+${C_RESET} %-20s [${C_REPO}repo${C_RESET}]\n" "$prog"
                    ((added++))
                fi
            done
        fi
        echo ""
        [[ $pruned -gt 0 ]] && echo "Pruned $pruned excluded entries"
        echo "Added $added packages to manifest"
        ;;

    untrack)
        [[ -z "$2" ]] && { echo "Usage: sat untrack <program> [program2] ..."; exit 1; }
        shift
        for prog in "$@"; do
            if [[ -z "$(manifest_get "$prog")" ]]; then
                echo "$prog: not tracked"
                continue
            fi
            manifest_remove "$prog"
            echo "$prog: untracked"
        done
        ;;

    clone)
        [[ -z "$2" ]] && { echo "Usage: sat clone <repo> [destination]"; exit 1; }
        REPO="$2"
        DEST="${3:-.}"
        [[ -z "$3" ]] && read -p "Where to clone? (default: ./): " DEST && DEST="${DEST:-.}"
        echo "Cloning $GITHUB_USER/$REPO to $DEST..."
        git clone "https://github.com/$GITHUB_USER/$REPO.git" "$DEST/$REPO"
        ;;

    update)
        cd "$HOME/.config/bash" || exit 1
        git pull
        ;;

    which|whereis)
        [[ -z "$2" ]] && { echo "Usage: sat which <program> [program2] ..."; exit 1; }
        shift
        for prog in "$@"; do
            # Get all installations
            all_sources=$(resolve_all_sources "$prog")
            if [[ -z "$all_sources" ]]; then
                echo "$prog: not found"
                continue
            fi

            first=true
            while IFS=: read -r src path status; do
                display=$(source_display "$src")
                color=$(source_color "$display")
                light=$(source_light "$src")

                if [[ "$status" == "active" ]]; then
                    printf "${light}%-15s${C_RESET} [${color}%s${C_RESET}] %s ${C_DIM}‚Üê active${C_RESET}\n" "$prog" "$display" "$path"
                else
                    if $first; then
                        printf "${light}%-15s${C_RESET} [${color}%s${C_RESET}] %s\n" "$prog" "$display" "$path"
                    else
                        printf "${C_DIM}%-15s [%s] %s (shadowed)${C_RESET}\n" "" "$display" "$path"
                    fi
                fi
                first=false
            done <<< "$all_sources"
        done
        ;;

    info)
        [[ -z "$2" ]] && { echo "Usage: sat info <program>"; exit 1; }
        prog="$2"
        bin=$(command -v "$prog" 2>/dev/null)
        if [[ -z "$bin" ]]; then
            echo "$prog: not found"
            exit 1
        fi
        real=$(readlink -f "$bin" 2>/dev/null || echo "$bin")
        src=$(resolve_source "$prog" "")
        display=$(source_display "$src")
        color=$(source_color "$display")
        tracked=$(manifest_get "$prog")
        ver=$("$prog" --version 2>/dev/null | head -1 || echo "unknown")

        echo "$prog"
        printf "  source:  ${color}%s${C_RESET}\n" "$display"
        echo "  path:    $bin"
        [[ "$real" != "$bin" ]] && echo "  target:  $real"
        [[ -n "$tracked" ]] && echo "  tracked: yes (sat manifest)"
        echo "  version: $ver"
        ;;

    *)
        cat << 'EOF'
         ,-.
        / \  `.  __..-,O
       :   \ --''_..-'.'
       |    . .-' `. '.
       :     .     .`.'
        \     `.  /  ..
         \      `.   ' .
          `,       `.   \
         ,|,`.        `-.\
        '.||  ``-...__..-`
         |  |
         |__|
         /||\    Usage: sat <command>
        //||\\
       // || \\
    __//__||__\\__
   '--------------'

Commands:
  install|i <pkg>     - Install package(s) with optional source
  search <program>    - Find package across sources (--all raw, --wrap full)
  uninstall|rm <prog> - Remove program installed via sat
  shell <tool>        - Temp shell with tools, auto-cleanup on exit
  which|whereis <prg> - Show source and path for installed programs
  info <program>      - Detailed info (source, path, version, tracking)
  list|ls             - List tracked packages (auto-cleans stale entries)
  track <program>     - Add existing program to manifest for sat management
  untrack <program>   - Remove from manifest without uninstalling
  scan                - Scan ecosystem dirs and add all found packages
  clone <repo> [dest] - Clone your repo
  update              - Pull latest bash config

Source syntax (install/shell):
  pkg:sys             - System package manager (apt/pacman/etc)
  pkg:brew            - Homebrew
  pkg:nix             - Nix profile
  pkg:rs :rust        - Cargo (Rust)
  pkg:py :python      - uv (Python)
  pkg:js :node        - npm (Node)
  pkg:go              - go install

Examples:
  sat install fd:rs bat:rs ripgrep:rs
  sat shell hyperfine:brew cowsay:sys jq
EOF
        ;;
esac
